#!/usr/bin/env bash
# start_interactive.sh - Menu Interativo para Gerenciamento de ServiÃ§os MyIA
# Permite selecionar quais serviÃ§os iniciar com barras de progresso visuais
#
# Uso: ./start_interactive.sh

set -euo pipefail

ROOT_DIR="$(cd "$(dirname "$0")" && pwd)"
BACKEND_DIR="$ROOT_DIR/backend"
FRONTEND_DIR="$ROOT_DIR/frontend"
FRONTEND_ADMIN_DIR="$ROOT_DIR/frontend-admin"
OBSERVABILITY_DIR="$ROOT_DIR/observability"
LOG_DIR="$ROOT_DIR/logs"
mkdir -p "$LOG_DIR"

# Arquivos de PID
PID_FILE_BACKEND="$LOG_DIR/backend.pid"
PID_FILE_FRONTEND="$LOG_DIR/frontend.pid"
PID_FILE_WORKER="$LOG_DIR/worker.pid"
PID_FILE_FRONTEND_ADMIN="$LOG_DIR/frontend-admin.pid"

# Logs
OUT_LOG_WORKER="$LOG_DIR/worker.out.log"
ERR_LOG_WORKER="$LOG_DIR/worker.err.log"
OUT_LOG_FRONTEND_ADMIN="$LOG_DIR/frontend-admin.out.log"
ERR_LOG_FRONTEND_ADMIN="$LOG_DIR/frontend-admin.err.log"

# Portas
REDIS_PORT=6379
POSTGRES_PORT=5432
BACKEND_PORT=3001
FRONTEND_PORT=3000
FRONTEND_ADMIN_PORT=3003
WORKER_HEALTH_PORT=3004
GRAFANA_PORT=3002

# Cores
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
WHITE='\033[1;37m'
GRAY='\033[0;90m'
NC='\033[0m'

# Modo Debug
DEBUG_MODE=0

debug_log() {
  if [ "$DEBUG_MODE" -eq 1 ]; then
    echo -e "${GRAY}[DEBUG] $*${NC}" >&2
  fi
}

# Estado dos serviÃ§os selecionados
declare -A SELECTED=(
  [1]=0  # Banco de Dados
  [2]=0  # Backend
  [3]=0  # Frontend
  [4]=0  # Frontend Admin
  [5]=0  # Worker
  [6]=0  # Grafana
)

# Progresso dos serviÃ§os
declare -A PROGRESS=(
  [1]=0  # Banco de Dados
  [2]=0  # Backend
  [3]=0  # Frontend
  [4]=0  # Frontend Admin
  [5]=0  # Worker
  [6]=0  # Grafana
)

# Status dos serviÃ§os
declare -A STATUS=(
  [1]="pending"  # pending, starting, running, error
  [2]="pending"
  [3]="pending"
  [4]="pending"
  [5]="pending"
  [6]="pending"
)

# Status de execuÃ§Ã£o dos serviÃ§os (detectado em tempo real)
declare -A RUNNING_STATUS=(
  [1]=0  # 0=parado, 1=rodando
  [2]=0
  [3]=0
  [4]=0
  [5]=0
  [6]=0
)

# ============================================================================
# FUNÃ‡Ã•ES DE VALIDAÃ‡ÃƒO
# ============================================================================

check_prerequisites() {
  local missing=()
  
  # Verificar Docker
  if ! command -v docker &>/dev/null; then
    missing+=("Docker")
  fi
  
  # Verificar npm
  if ! command -v npm &>/dev/null; then
    missing+=("npm")
  fi
  
  # Verificar Node.js (versÃ£o mÃ­nima 18)
  if ! command -v node &>/dev/null; then
    missing+=("Node.js")
  else
    local node_version=$(node -v | cut -d'v' -f2 | cut -d'.' -f1)
    if [ "$node_version" -lt 18 ]; then
      echo -e "${RED}âŒ Node.js versÃ£o 18+ necessÃ¡ria (atual: v$node_version)${NC}"
      exit 1
    fi
  fi
  
  # Verificar lsof
  if ! command -v lsof &>/dev/null; then
    missing+=("lsof")
  fi
  
  if [ ${#missing[@]} -gt 0 ]; then
    echo -e "${RED}âŒ Ferramentas ausentes: ${missing[*]}${NC}"
    echo -e "${YELLOW}Instale as dependÃªncias e tente novamente.${NC}"
    exit 1
  fi
}

validate_directories() {
  local dirs=(
    "$BACKEND_DIR"
    "$FRONTEND_DIR"
    "$FRONTEND_ADMIN_DIR"
    "$OBSERVABILITY_DIR"
  )
  
  for dir in "${dirs[@]}"; do
    if [ ! -d "$dir" ]; then
      echo -e "${RED}âŒ DiretÃ³rio nÃ£o encontrado: $dir${NC}"
      exit 1
    fi
  done
  
  # Verificar package.json
  if [ ! -f "$BACKEND_DIR/package.json" ]; then
    echo -e "${RED}âŒ Backend package.json nÃ£o encontrado${NC}"
    exit 1
  fi
  
  # Verificar node_modules do backend
  if [ ! -d "$BACKEND_DIR/node_modules" ]; then
    echo -e "${YELLOW}âš ï¸  Backend node_modules nÃ£o encontrado.${NC}"
    read -p "Deseja instalar agora? (s/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Ss]$ ]]; then
      echo -e "${CYAN}Instalando dependÃªncias do backend...${NC}"
      (cd "$BACKEND_DIR" && npm install)
    else
      exit 1
    fi
  fi
  
  # Verificar node_modules do frontend
  if [ ! -d "$FRONTEND_DIR/node_modules" ]; then
    echo -e "${YELLOW}âš ï¸  Frontend node_modules nÃ£o encontrado.${NC}"
    read -p "Deseja instalar agora? (s/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Ss]$ ]]; then
      echo -e "${CYAN}Instalando dependÃªncias do frontend...${NC}"
      (cd "$FRONTEND_DIR" && npm install)
    else
      exit 1
    fi
  fi
  
  # Verificar node_modules do frontend-admin
  if [ ! -d "$FRONTEND_ADMIN_DIR/node_modules" ]; then
    echo -e "${YELLOW}âš ï¸  Frontend Admin node_modules nÃ£o encontrado.${NC}"
    read -p "Deseja instalar agora? (s/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Ss]$ ]]; then
      echo -e "${CYAN}Instalando dependÃªncias do frontend-admin...${NC}"
      (cd "$FRONTEND_ADMIN_DIR" && npm install)
    else
      exit 1
    fi
  fi
}

check_port_available() {
  local port=$1
  local service_name=$2
  
  if lsof -ti:$port >/dev/null 2>&1; then
    local pid=$(lsof -ti:$port)
    echo -e "${YELLOW}âš ï¸  Porta $port jÃ¡ estÃ¡ em uso (PID $pid)${NC}"
    echo -e "${CYAN}ServiÃ§o: $service_name${NC}"
    read -p "Deseja parar o processo existente? (s/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Ss]$ ]]; then
      kill $pid 2>/dev/null || true
      sleep 2
      return 0
    else
      return 1
    fi
  fi
  return 0
}

validate_env_files() {
  # Backend .env
  if [ ! -f "$BACKEND_DIR/.env" ]; then
    echo -e "${YELLOW}âš ï¸  Backend .env nÃ£o encontrado${NC}"
    if [ -f "$BACKEND_DIR/.env.example" ]; then
      echo -e "${CYAN}Copiando .env.example para .env...${NC}"
      cp "$BACKEND_DIR/.env.example" "$BACKEND_DIR/.env"
      echo -e "${YELLOW}âš ï¸  Configure as variÃ¡veis em $BACKEND_DIR/.env${NC}"
      read -p "Pressione ENTER apÃ³s configurar..."
    else
      echo -e "${RED}âŒ .env.example tambÃ©m nÃ£o encontrado${NC}"
      exit 1
    fi
  fi
  
  # Carregar e verificar variÃ¡veis crÃ­ticas
  if [ -f "$BACKEND_DIR/.env" ]; then
    source "$BACKEND_DIR/.env"
    local required_vars=("DATABASE_URL" "JWT_SECRET")
    for var in "${required_vars[@]}"; do
      if [ -z "${!var}" ]; then
        echo -e "${RED}âŒ VariÃ¡vel $var nÃ£o definida em .env${NC}"
        exit 1
      fi
    done
  fi
}

cleanup_orphan_pids() {
  local pid_files=(
    "$PID_FILE_BACKEND"
    "$PID_FILE_FRONTEND"
    "$PID_FILE_WORKER"
    "$PID_FILE_FRONTEND_ADMIN"
  )
  
  for pid_file in "${pid_files[@]}"; do
    if [ -f "$pid_file" ]; then
      local pid=$(cat "$pid_file")
      if ! kill -0 $pid >/dev/null 2>&1; then
        echo -e "${YELLOW}âš ï¸  Removendo PID Ã³rfÃ£o: $(basename "$pid_file") (PID $pid)${NC}"
        rm -f "$pid_file"
      fi
    fi
  done
}

rotate_logs() {
  local max_size_mb=50
  local max_files=5
  
  debug_log "Verificando logs para rotaÃ§Ã£o (limite: ${max_size_mb}MB)"
  
  # Iterar sobre todos os arquivos .log no diretÃ³rio de logs
  for log_file in "$LOG_DIR"/*.log; do
    # Verificar se arquivo existe (evitar erro se nÃ£o houver .log)
    [ -f "$log_file" ] || continue
    
    # Obter tamanho do arquivo em MB
    local size_mb=$(du -m "$log_file" 2>/dev/null | cut -f1)
    
    # Se arquivo maior que limite, rotacionar
    if [ "$size_mb" -gt "$max_size_mb" ]; then
      local basename=$(basename "$log_file")
      echo -e "${YELLOW}âš ï¸  Rotacionando log: $basename (${size_mb}MB)${NC}"
      
      debug_log "Rotacionando $basename: ${size_mb}MB > ${max_size_mb}MB"
      
      # Deletar arquivo mais antigo se existir
      [ -f "${log_file}.${max_files}" ] && rm -f "${log_file}.${max_files}"
      
      # Rotacionar arquivos existentes (do mais novo para o mais antigo)
      for i in $(seq $((max_files - 1)) -1 1); do
        if [ -f "${log_file}.$i" ]; then
          mv "${log_file}.$i" "${log_file}.$((i + 1))"
          debug_log "Movido ${basename}.$i -> ${basename}.$((i + 1))"
        fi
      done
      
      # Mover log atual para .1
      mv "$log_file" "${log_file}.1"
      debug_log "Movido ${basename} -> ${basename}.1"
      
      # Criar novo arquivo vazio
      touch "$log_file"
    fi
  done
}

validate_service_dependencies() {
  debug_log "Validando dependÃªncias entre serviÃ§os"
  
  # Backend requer Database (serviÃ§o 1)
  if [[ "${SELECTED[2]}" == "1" ]] && [[ "${SELECTED[1]}" != "1" ]]; then
    echo -e "${YELLOW}âš ï¸  Backend requer Database. Habilitando Database automaticamente...${NC}"
    SELECTED[1]=1
    debug_log "DependÃªncia habilitada: Database para Backend"
    sleep 2
  fi
  
  # Worker requer Backend (serviÃ§o 2)
  if [[ "${SELECTED[5]}" == "1" ]] && [[ "${SELECTED[2]}" != "1" ]]; then
    echo -e "${YELLOW}âš ï¸  Worker requer Backend. Habilitando Backend automaticamente...${NC}"
    SELECTED[2]=1
    debug_log "DependÃªncia habilitada: Backend para Worker"
    sleep 2
    
    # Backend requer Database, verificar novamente
    if [[ "${SELECTED[1]}" != "1" ]]; then
      echo -e "${YELLOW}âš ï¸  Backend requer Database. Habilitando Database automaticamente...${NC}"
      SELECTED[1]=1
      debug_log "DependÃªncia habilitada: Database para Backend (via Worker)"
      sleep 2
    fi
  fi
  
  # Frontend requer Backend (serviÃ§o 2)
  if [[ "${SELECTED[3]}" == "1" ]] && [[ "${SELECTED[2]}" != "1" ]]; then
    echo -e "${YELLOW}âš ï¸  Frontend requer Backend. Habilitando Backend automaticamente...${NC}"
    SELECTED[2]=1
    debug_log "DependÃªncia habilitada: Backend para Frontend"
    sleep 2
    
    # Backend requer Database, verificar novamente
    if [[ "${SELECTED[1]}" != "1" ]]; then
      echo -e "${YELLOW}âš ï¸  Backend requer Database. Habilitando Database automaticamente...${NC}"
      SELECTED[1]=1
      debug_log "DependÃªncia habilitada: Database para Backend (via Frontend)"
      sleep 2
    fi
  fi
  
  # Frontend Admin requer Backend (serviÃ§o 2)
  if [[ "${SELECTED[4]}" == "1" ]] && [[ "${SELECTED[2]}" != "1" ]]; then
    echo -e "${YELLOW}âš ï¸  Frontend Admin requer Backend. Habilitando Backend automaticamente...${NC}"
    SELECTED[2]=1
    debug_log "DependÃªncia habilitada: Backend para Frontend Admin"
    sleep 2
    
    # Backend requer Database, verificar novamente
    if [[ "${SELECTED[1]}" != "1" ]]; then
      echo -e "${YELLOW}âš ï¸  Backend requer Database. Habilitando Database automaticamente...${NC}"
      SELECTED[1]=1
      debug_log "DependÃªncia habilitada: Database para Backend (via Frontend Admin)"
      sleep 2
    fi
  fi
}

wait_for_port() {
  local port=$1
  local service_name=$2
  local max_wait=${3:-30}
  local pid_file=$4
  
  debug_log "Aguardando porta $port para $service_name (timeout: ${max_wait}s)"
  
  local waited=0
  while [ $waited -lt $max_wait ]; do
    # Verificar se porta estÃ¡ aberta
    if lsof -ti:$port >/dev/null 2>&1; then
      debug_log "Porta $port aberta apÃ³s ${waited}s"
      return 0
    fi
    
    # Se PID fornecido, verificar se processo ainda estÃ¡ vivo
    if [ -n "$pid_file" ] && [ -f "$pid_file" ]; then
      if ! kill -0 "$(cat "$pid_file")" >/dev/null 2>&1; then
        echo ""
        echo -e "${RED}âŒ $service_name morreu durante inicializaÃ§Ã£o${NC}"
        echo -e "${YELLOW}ðŸ’¡ Veja os logs para mais detalhes${NC}"
        debug_log "Processo morreu durante inicializaÃ§Ã£o (PID file: $pid_file)"
        return 1
      fi
    fi
    
    sleep 1
    waited=$((waited + 1))
  done
  
  echo ""
  echo -e "${RED}âŒ $service_name nÃ£o respondeu apÃ³s $max_wait segundos${NC}"
  echo -e "${YELLOW}ðŸ’¡ O serviÃ§o pode estar travado ou com erro${NC}"
  debug_log "Timeout aguardando porta $port apÃ³s ${max_wait}s"
  return 1
}

show_error_logs() {
  local service_name=$1
  local error_log_path=$2
  
  echo ""
  echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${RED}âŒ $service_name falhou ao iniciar${NC}"
  echo -e "${RED}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  
  # Mostrar Ãºltimas 10 linhas do log de erro se existir
  if [ -f "$error_log_path" ] && [ -s "$error_log_path" ]; then
    echo -e "${WHITE}Ãšltimas 10 linhas do log de erro:${NC}"
    echo ""
    tail -n 10 "$error_log_path" | while IFS= read -r line; do
      echo -e "${GRAY}  $line${NC}"
    done
    echo ""
  fi
  
  # SugestÃµes de troubleshooting
  echo -e "${YELLOW}ðŸ’¡ SugestÃµes:${NC}"
  
  case "$service_name" in
    Backend|Worker)
      echo -e "${CYAN}  â€¢ Verifique se as dependÃªncias estÃ£o instaladas: cd backend && npm install${NC}"
      echo -e "${CYAN}  â€¢ Verifique o arquivo .env: cat backend/.env${NC}"
      echo -e "${CYAN}  â€¢ Veja o log completo: cat $error_log_path${NC}"
      ;;
    Frontend)
      echo -e "${CYAN}  â€¢ Verifique se as dependÃªncias estÃ£o instaladas: cd frontend && npm install${NC}"
      echo -e "${CYAN}  â€¢ Verifique variÃ¡veis de ambiente${NC}"
      echo -e "${CYAN}  â€¢ Veja o log completo: cat $error_log_path${NC}"
      ;;
    "Frontend Admin")
      echo -e "${CYAN}  â€¢ Verifique se as dependÃªncias estÃ£o instaladas: cd frontend-admin && npm install${NC}"
      echo -e "${CYAN}  â€¢ Verifique variÃ¡veis de ambiente${NC}"
      echo -e "${CYAN}  â€¢ Veja o log completo: cat $error_log_path${NC}"
      ;;
    Grafana)
      echo -e "${CYAN}  â€¢ Verifique se Docker estÃ¡ rodando: docker ps${NC}"
      echo -e "${CYAN}  â€¢ Verifique o script de inicializaÃ§Ã£o: ls -la observability/start.sh${NC}"
      echo -e "${CYAN}  â€¢ Verifique se a porta 3002 estÃ¡ disponÃ­vel: lsof -ti:3002${NC}"
      echo -e "${CYAN}  â€¢ Veja o log completo: cat $error_log_path${NC}"
      ;;
    *)
      echo -e "${CYAN}  â€¢ Veja o log completo: cat $error_log_path${NC}"
      ;;
  esac
  
  echo ""
}

graceful_kill() {
  local pid=$1
  local service_name=$2
  local timeout=${3:-10}
  
  debug_log "Tentando parar $service_name (PID $pid, timeout: ${timeout}s)"
  
  # Verificar se processo existe
  if ! kill -0 $pid >/dev/null 2>&1; then
    echo -e "${GRAY}$service_name jÃ¡ estÃ¡ parado${NC}"
    debug_log "Processo $pid jÃ¡ estava parado"
    return 0
  fi
  
  echo -e "${BLUE}Parando $service_name (PID $pid)...${NC}"
  
  # Enviar SIGTERM
  debug_log "Enviando SIGTERM para PID $pid ($service_name)"
  kill -TERM $pid >/dev/null 2>&1 || true
  
  # Aguardar atÃ© timeout
  local waited=0
  while [ $waited -lt $timeout ]; do
    if ! kill -0 $pid >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“ $service_name parado gracefully${NC}"
      debug_log "Processo $pid parado gracefully apÃ³s ${waited}s"
      return 0
    fi
    sleep 1
    waited=$((waited + 1))
  done
  
  # Se nÃ£o respondeu, forÃ§ar parada
  echo -e "${YELLOW}âš ï¸  $service_name nÃ£o respondeu, forÃ§ando parada...${NC}"
  debug_log "Processo $pid nÃ£o respondeu, enviando SIGKILL"
  kill -9 $pid >/dev/null 2>&1 || true
  sleep 1
  
  # Verificar se realmente parou
  if ! kill -0 $pid >/dev/null 2>&1; then
    echo -e "${GREEN}âœ“ $service_name parado (forÃ§ado)${NC}"
    debug_log "Processo $pid parado com SIGKILL"
    return 0
  else
    echo -e "${RED}âŒ Falha ao parar $service_name${NC}"
    debug_log "ERRO: Falha ao parar processo $pid"
    return 1
  fi
}

# ============================================================================
# FUNÃ‡Ã•ES DE INTERFACE
# ============================================================================

check_service_status() {
  local service=$1
  
  case "$service" in
    1) # Database
      if docker ps --format '{{.Names}}' | grep -q "^myia-redis$" && lsof -ti:$POSTGRES_PORT >/dev/null 2>&1; then
        return 0  # Rodando
      fi
      ;;
    2) # Backend
      if [ -f "$PID_FILE_BACKEND" ] && kill -0 "$(cat "$PID_FILE_BACKEND")" >/dev/null 2>&1; then
        return 0
      fi
      ;;
    3) # Frontend
      if [ -f "$PID_FILE_FRONTEND" ] && kill -0 "$(cat "$PID_FILE_FRONTEND")" >/dev/null 2>&1; then
        return 0
      fi
      ;;
    4) # Frontend Admin
      if [ -f "$PID_FILE_FRONTEND_ADMIN" ] && kill -0 "$(cat "$PID_FILE_FRONTEND_ADMIN")" >/dev/null 2>&1; then
        return 0
      fi
      ;;
    5) # Worker
      if [ -f "$PID_FILE_WORKER" ] && kill -0 "$(cat "$PID_FILE_WORKER")" >/dev/null 2>&1; then
        return 0
      fi
      ;;
    6) # Grafana
      if lsof -ti:$GRAFANA_PORT >/dev/null 2>&1; then
        return 0
      fi
      ;;
  esac
  
  return 1  # NÃ£o rodando
}

update_running_status() {
  for i in {1..6}; do
    if check_service_status "$i"; then
      RUNNING_STATUS[$i]=1
    else
      RUNNING_STATUS[$i]=0
    fi
  done
}

clear_screen() {
  clear
  # Mover cursor para o topo
  tput cup 0 0
}

hide_cursor() {
  tput civis
}

show_cursor() {
  tput cnorm
}

draw_box_top() {
  echo -e "${BLUE}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
}

draw_box_middle() {
  echo -e "${BLUE}â•‘${NC} $1"
}

draw_box_bottom() {
  echo -e "${BLUE}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
}

show_menu() {
  clear_screen
  
  # Atualizar status dos serviÃ§os
  update_running_status
  
  draw_box_top
  local title="              ðŸš€ MyIA - Gerenciador de ServiÃ§os             "
  echo -e "${BLUE}â•‘${WHITE}${title}${BLUE}â•‘${NC}"
  draw_box_bottom
  
  echo ""
  echo -e "${CYAN}Selecione os serviÃ§os que deseja iniciar:${NC}"
  echo ""
  
  # ServiÃ§o 1: Banco de Dados
  local checkbox1="[ ]"
  [[ "${SELECTED[1]}" == "1" ]] && checkbox1="[${GREEN}x${NC}]"
  
  local status_indicator1=""
  if [[ "${RUNNING_STATUS[1]}" == "1" ]]; then
    status_indicator1=" ${GREEN}(âœ“ rodando)${NC}"
  fi
  
  echo -e " ${checkbox1} ${BLUE}1.${NC} Banco de Dados (Redis + PostgreSQL)${status_indicator1}"
  echo -e "     ${GRAY}â””â”€ Armazena informaÃ§Ãµes e gerencia filas de tarefas${NC}"
  echo ""
  
  # ServiÃ§o 2: Backend
  local checkbox2="[ ]"
  [[ "${SELECTED[2]}" == "1" ]] && checkbox2="[${GREEN}x${NC}]"
  
  local status_indicator2=""
  if [[ "${RUNNING_STATUS[2]}" == "1" ]]; then
    status_indicator2=" ${GREEN}(âœ“ rodando)${NC}"
  fi
  
  echo -e " ${checkbox2} ${BLUE}2.${NC} API do Sistema (Backend)${status_indicator2}"
  echo -e "     ${GRAY}â””â”€ Servidor que processa requisiÃ§Ãµes e se comunica com IA${NC}"
  echo ""
  
  # ServiÃ§o 3: Frontend
  local checkbox3="[ ]"
  [[ "${SELECTED[3]}" == "1" ]] && checkbox3="[${GREEN}x${NC}]"
  
  local status_indicator3=""
  if [[ "${RUNNING_STATUS[3]}" == "1" ]]; then
    status_indicator3=" ${GREEN}(âœ“ rodando)${NC}"
  fi
  
  echo -e " ${checkbox3} ${BLUE}3.${NC} Interface do UsuÃ¡rio (Frontend)${status_indicator3}"
  echo -e "     ${GRAY}â””â”€ Tela principal onde vocÃª conversa com os modelos de IA${NC}"
  echo ""
  
  # ServiÃ§o 4: Frontend Admin
  local checkbox4="[ ]"
  [[ "${SELECTED[4]}" == "1" ]] && checkbox4="[${GREEN}x${NC}]"
  
  local status_indicator4=""
  if [[ "${RUNNING_STATUS[4]}" == "1" ]]; then
    status_indicator4=" ${GREEN}(âœ“ rodando)${NC}"
  fi
  
  echo -e " ${checkbox4} ${BLUE}4.${NC} Painel de AdministraÃ§Ã£o (Frontend Admin)${status_indicator4}"
  echo -e "     ${GRAY}â””â”€ Tela para gerenciar e testar modelos de IA${NC}"
  echo ""
  
  # ServiÃ§o 5: Worker
  local checkbox5="[ ]"
  [[ "${SELECTED[5]}" == "1" ]] && checkbox5="[${GREEN}x${NC}]"
  
  local status_indicator5=""
  if [[ "${RUNNING_STATUS[5]}" == "1" ]]; then
    status_indicator5=" ${GREEN}(âœ“ rodando)${NC}"
  fi
  
  echo -e " ${checkbox5} ${BLUE}5.${NC} Processador de Tarefas (Worker)${status_indicator5}"
  echo -e "     ${GRAY}â””â”€ Executa testes de modelos em segundo plano${NC}"
  echo ""
  
  # ServiÃ§o 6: Grafana
  local checkbox6="[ ]"
  [[ "${SELECTED[6]}" == "1" ]] && checkbox6="[${GREEN}x${NC}]"
  
  local status_indicator6=""
  if [[ "${RUNNING_STATUS[6]}" == "1" ]]; then
    status_indicator6=" ${GREEN}(âœ“ rodando)${NC}"
  fi
  
  echo -e " ${checkbox6} ${BLUE}6.${NC} Monitoramento (Grafana)${status_indicator6}"
  echo -e "     ${GRAY}â””â”€ Visualiza logs, erros e mÃ©tricas do sistema${NC}"
  echo ""
  
  # Mostrar aviso se tentar iniciar serviÃ§os jÃ¡ rodando
  local any_running_selected=0
  for i in {1..6}; do
    if [[ "${SELECTED[$i]}" == "1" ]] && [[ "${RUNNING_STATUS[$i]}" == "1" ]]; then
      any_running_selected=1
      break
    fi
  done
  
  if [ "$any_running_selected" -eq 1 ]; then
    echo ""
    echo -e " ${YELLOW}âš ï¸  Alguns serviÃ§os selecionados jÃ¡ estÃ£o rodando${NC}"
    echo -e " ${GRAY}   (serÃ£o reiniciados se vocÃª prosseguir)${NC}"
  fi
  
  echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo ""
  echo -e "${GRAY}ðŸ’¡ Dica: Selecione serviÃ§os (1-6) e pressione ENTER para iniciar${NC}"
  echo ""
  echo -e " [${GREEN}x${NC}] ${BLUE}7.${NC} ${GREEN}INICIAR TUDO${NC} (Recomendado)"
  echo -e " [ ] ${BLUE}8.${NC} Status dos ServiÃ§os"
  echo -e " [ ] ${BLUE}9.${NC} Parar Todos os ServiÃ§os"
  echo -e " [ ] ${BLUE}r.${NC} Reiniciar ServiÃ§o EspecÃ­fico"
  echo -e " [ ] ${BLUE}l.${NC} Ver Logs em Tempo Real"
  echo -e " [ ] ${BLUE}c.${NC} Limpar Logs Antigos"
  echo -e " [ ] ${BLUE}s.${NC} Salvar Perfil Atual"
  echo -e " [ ] ${BLUE}p.${NC} Carregar Perfil"
  echo -e " [ ] ${BLUE}0.${NC} Sair"
  echo ""
  echo -ne "${CYAN}OpÃ§Ã£o:${NC} "
}

toggle_service() {
  local service=$1
  if [[ "${SELECTED[$service]}" == "1" ]]; then
    SELECTED[$service]=0
  else
    SELECTED[$service]=1
  fi
}

select_all() {
  for i in {1..6}; do
    SELECTED[$i]=1
  done
}

deselect_all() {
  for i in {1..6}; do
    SELECTED[$i]=0
  done
}

# ============================================================================
# FUNÃ‡Ã•ES DE PROGRESSO
# ============================================================================

draw_progress_bar() {
  local current=$1
  local total=$2
  local width=20
  
  if [ "$total" -eq 0 ]; then
    total=1
  fi
  
  local percentage=$((current * 100 / total))
  local filled=$((width * current / total))
  local empty=$((width - filled))
  
  # Limitar valores
  if [ "$filled" -gt "$width" ]; then
    filled=$width
    empty=0
  fi
  if [ "$filled" -lt 0 ]; then
    filled=0
    empty=$width
  fi
  
  # Cor baseada no progresso
  local color=$YELLOW
  if [ "$percentage" -eq 100 ]; then
    color=$GREEN
  fi
  
  printf "${color}"
  printf 'â–ˆ%.0s' $(seq 1 $filled)
  printf "${GRAY}"
  printf 'â–‘%.0s' $(seq 1 $empty)
  printf "${NC}"
  printf " %3d%%" "$percentage"
}

get_status_icon() {
  local status=$1
  case "$status" in
    pending)  echo "â¸ï¸ " ;;
    starting) echo "â³" ;;
    running)  echo "âœ…" ;;
    error)    echo "âŒ" ;;
    *)        echo "  " ;;
  esac
}

show_progress() {
  clear_screen
  
  draw_box_top
  local title="              ðŸš€ Iniciando ServiÃ§os MyIA...              "
  echo -e "${BLUE}â•‘${WHITE}${title}${BLUE}â•‘${NC}"
  draw_box_bottom
  
  echo ""
  
  local total_selected=0
  local total_completed=0
  
  # Contar serviÃ§os selecionados
  for i in {1..6}; do
    if [[ "${SELECTED[$i]}" == "1" ]]; then
      total_selected=$((total_selected + 1))
      if [[ "${STATUS[$i]}" == "running" ]]; then
        total_completed=$((total_completed + 1))
      fi
    fi
  done
  
  if [ "$total_selected" -eq 0 ]; then
    total_selected=1
  fi
  
  # Mostrar progresso de cada serviÃ§o
  local service_names=(
    ""
    "Banco de Dados     "
    "API do Sistema     "
    "Interface          "
    "Painel Admin       "
    "Processador        "
    "Monitoramento      "
  )
  
  local idx=0
  for i in {1..6}; do
    if [[ "${SELECTED[$i]}" == "1" ]]; then
      idx=$((idx + 1))
      local icon=$(get_status_icon "${STATUS[$i]}")
      echo -ne "${CYAN}[$idx/$total_selected]${NC} ${service_names[$i]} "
      draw_progress_bar "${PROGRESS[$i]}" 100
      echo -e " $icon"
    fi
  done
  
  echo ""
  echo -ne "${WHITE}TOTAL                  ${NC}"
  local total_progress=$((total_completed * 100 / total_selected))
  draw_progress_bar "$total_progress" 100
  echo -e " ðŸš€"
  echo ""
}

# ============================================================================
# FUNÃ‡Ã•ES DE INICIALIZAÃ‡ÃƒO
# ============================================================================

start_database() {
  STATUS[1]="starting"
  PROGRESS[1]=10
  show_progress
  
  # Iniciar Redis
  if ! docker ps --format '{{.Names}}' | grep -q "^myia-redis$"; then
    docker ps -a --format '{{.Names}}' | grep -q "^myia-redis$" && docker rm -f myia-redis >/dev/null 2>&1 || true
    docker run -d --name myia-redis -p $REDIS_PORT:6379 --restart unless-stopped redis:7-alpine >/dev/null 2>&1
  fi
  
  PROGRESS[1]=30
  show_progress
  
  # Verificar Redis (MELHORADO)
  local max_wait=10
  local waited=0
  while [ $waited -lt $max_wait ]; do
    if docker exec myia-redis redis-cli ping >/dev/null 2>&1; then
      break
    fi
    sleep 1
    waited=$((waited + 1))
  done
  
  if [ $waited -eq $max_wait ]; then
    STATUS[1]="error"
    show_progress
    echo ""
    echo -e "${RED}âŒ Redis nÃ£o respondeu apÃ³s $max_wait segundos${NC}"
    return 1
  fi
  
  PROGRESS[1]=60
  show_progress
  
  # Verificar PostgreSQL
  sleep 1
  
  PROGRESS[1]=100
  STATUS[1]="running"
  show_progress
  sleep 1
}

start_backend_service() {
  debug_log "Iniciando backend em $BACKEND_DIR"
  
  STATUS[2]="starting"
  PROGRESS[2]=10
  show_progress
  
  # Verificar se jÃ¡ estÃ¡ rodando
  if [ -f "$PID_FILE_BACKEND" ] && kill -0 "$(cat "$PID_FILE_BACKEND")" >/dev/null 2>&1; then
    debug_log "Backend jÃ¡ estÃ¡ rodando (PID $(cat "$PID_FILE_BACKEND"))"
    PROGRESS[2]=100
    STATUS[2]="running"
    show_progress
    return 0
  fi
  
  PROGRESS[2]=30
  show_progress
  
  # Iniciar backend
  debug_log "PID file: $PID_FILE_BACKEND"
  debug_log "Comando: cd $BACKEND_DIR && npm run dev"
  (cd "$BACKEND_DIR" && npm run dev) >"$LOG_DIR/backend.out.log" 2>"$LOG_DIR/backend.err.log" &
  local pid=$!
  echo $pid >"$PID_FILE_BACKEND"
  debug_log "Backend iniciado com PID $pid"
  
  PROGRESS[2]=60
  show_progress
  
  # Aguardar inicializaÃ§Ã£o
  if wait_for_port $BACKEND_PORT "Backend" 30 "$PID_FILE_BACKEND"; then
    PROGRESS[2]=100
    STATUS[2]="running"
    show_progress
    debug_log "Backend iniciado com sucesso na porta $BACKEND_PORT"
    return 0
  else
    STATUS[2]="error"
    show_progress
    show_error_logs "Backend" "$LOG_DIR/backend.err.log"
    debug_log "ERRO: Falha ao iniciar backend"
    return 1
  fi
}

start_frontend_service() {
  STATUS[3]="starting"
  PROGRESS[3]=10
  show_progress
  
  # Verificar se jÃ¡ estÃ¡ rodando
  if [ -f "$PID_FILE_FRONTEND" ] && kill -0 "$(cat "$PID_FILE_FRONTEND")" >/dev/null 2>&1; then
    PROGRESS[3]=100
    STATUS[3]="running"
    show_progress
    return 0
  fi
  
  PROGRESS[3]=30
  show_progress
  
  # Iniciar frontend
  (cd "$FRONTEND_DIR" && npm run dev) >"$LOG_DIR/frontend.out.log" 2>"$LOG_DIR/frontend.err.log" &
  echo $! >"$PID_FILE_FRONTEND"
  
  PROGRESS[3]=60
  show_progress
  
  # Aguardar inicializaÃ§Ã£o
  if wait_for_port $FRONTEND_PORT "Frontend" 30 "$PID_FILE_FRONTEND"; then
    PROGRESS[3]=100
    STATUS[3]="running"
    show_progress
    return 0
  else
    STATUS[3]="error"
    show_progress
    show_error_logs "Frontend" "$LOG_DIR/frontend.err.log"
    return 1
  fi
}

start_frontend_admin_service() {
  STATUS[4]="starting"
  PROGRESS[4]=10
  show_progress
  
  # Verificar se jÃ¡ estÃ¡ rodando
  if [ -f "$PID_FILE_FRONTEND_ADMIN" ] && kill -0 "$(cat "$PID_FILE_FRONTEND_ADMIN")" >/dev/null 2>&1; then
    PROGRESS[4]=100
    STATUS[4]="running"
    show_progress
    return 0
  fi
  
  PROGRESS[4]=30
  show_progress
  
  # Iniciar frontend-admin
  (cd "$FRONTEND_ADMIN_DIR" && npm run dev) >"$OUT_LOG_FRONTEND_ADMIN" 2>"$ERR_LOG_FRONTEND_ADMIN" &
  echo $! >"$PID_FILE_FRONTEND_ADMIN"
  
  PROGRESS[4]=60
  show_progress
  
  # Aguardar inicializaÃ§Ã£o
  if wait_for_port $FRONTEND_ADMIN_PORT "Frontend Admin" 30 "$PID_FILE_FRONTEND_ADMIN"; then
    PROGRESS[4]=100
    STATUS[4]="running"
    show_progress
    return 0
  else
    STATUS[4]="error"
    show_progress
    show_error_logs "Frontend Admin" "$ERR_LOG_FRONTEND_ADMIN"
    return 1
  fi
}

start_worker_service() {
  debug_log "Iniciando worker em $BACKEND_DIR"
  
  STATUS[5]="starting"
  PROGRESS[5]=10
  show_progress
  
  # Verificar se jÃ¡ estÃ¡ rodando
  if [ -f "$PID_FILE_WORKER" ] && kill -0 "$(cat "$PID_FILE_WORKER")" >/dev/null 2>&1; then
    debug_log "Worker jÃ¡ estÃ¡ rodando (PID $(cat "$PID_FILE_WORKER"))"
    PROGRESS[5]=100
    STATUS[5]="running"
    show_progress
    return 0
  fi
  
  PROGRESS[5]=30
  show_progress
  
  # Iniciar worker
  debug_log "PID file: $PID_FILE_WORKER"
  debug_log "Comando: cd $BACKEND_DIR && npm run worker:dev"
  (cd "$BACKEND_DIR" && npm run worker:dev) >"$OUT_LOG_WORKER" 2>"$ERR_LOG_WORKER" &
  local pid=$!
  echo $pid >"$PID_FILE_WORKER"
  debug_log "Worker iniciado com PID $pid"
  
  PROGRESS[5]=60
  show_progress
  
  # Aguardar inicializaÃ§Ã£o
  if wait_for_port $WORKER_HEALTH_PORT "Worker" 30 "$PID_FILE_WORKER"; then
    PROGRESS[5]=100
    STATUS[5]="running"
    show_progress
    debug_log "Worker iniciado com sucesso na porta $WORKER_HEALTH_PORT"
    return 0
  else
    STATUS[5]="error"
    show_progress
    show_error_logs "Worker" "$ERR_LOG_WORKER"
    debug_log "ERRO: Falha ao iniciar worker"
    return 1
  fi
}

start_grafana_service() {
  debug_log "Iniciando Grafana em $OBSERVABILITY_DIR"
  
  STATUS[6]="starting"
  PROGRESS[6]=10
  show_progress
  
  # Verificar se jÃ¡ estÃ¡ rodando (usar health check HTTP ao invÃ©s de lsof)
  if curl -s http://localhost:$GRAFANA_PORT/api/health >/dev/null 2>&1; then
    debug_log "Grafana jÃ¡ estÃ¡ rodando e respondendo health check"
    PROGRESS[6]=100
    STATUS[6]="running"
    show_progress
    return 0
  fi
  
  PROGRESS[6]=20
  show_progress
  
  # Verificar se script de inicializaÃ§Ã£o existe
  if [ ! -f "$OBSERVABILITY_DIR/start.sh" ]; then
    debug_log "ERRO: Script start.sh nÃ£o encontrado em $OBSERVABILITY_DIR"
    STATUS[6]="error"
    show_progress
    show_error_logs "Grafana" "$LOG_DIR/grafana.err.log"
    echo -e "${YELLOW}ðŸ’¡ Script start.sh nÃ£o encontrado em: $OBSERVABILITY_DIR${NC}"
    echo ""
    return 1
  fi
  
  PROGRESS[6]=30
  show_progress
  
  # Iniciar Grafana via Docker Compose
  # NOTA: O script start.sh termina apÃ³s iniciar containers Docker, mas os containers continuam rodando
  debug_log "Executando: cd $OBSERVABILITY_DIR && ./start.sh"
  (cd "$OBSERVABILITY_DIR" && ./start.sh) >"$LOG_DIR/grafana.out.log" 2>"$LOG_DIR/grafana.err.log" &
  local grafana_pid=$!
  debug_log "Grafana iniciado com PID $grafana_pid (script termina mas containers permanecem)"
  
  PROGRESS[6]=50
  show_progress
  
  # Aguardar inicializaÃ§Ã£o com timeout aumentado
  local max_wait=30
  local waited=0
  local health_check_failed=0
  
  debug_log "Aguardando Grafana responder (timeout: ${max_wait}s)"
  
  while [ $waited -lt $max_wait ]; do
    # MÃ‰TODO PRINCIPAL: Health check HTTP (funciona com Docker)
    if curl -s http://localhost:$GRAFANA_PORT/api/health >/dev/null 2>&1; then
      debug_log "Grafana health check OK apÃ³s ${waited}s"
      PROGRESS[6]=100
      STATUS[6]="running"
      show_progress
      
      # Aguardar 2 segundos para estabilizar
      sleep 2
      
      # Verificar novamente via health check
      if curl -s http://localhost:$GRAFANA_PORT/api/health >/dev/null 2>&1; then
        debug_log "Grafana confirmado rodando e estÃ¡vel"
        return 0
      else
        echo ""
        echo -e "${YELLOW}âš ï¸  Grafana parou logo apÃ³s iniciar${NC}"
        debug_log "AVISO: Grafana parou apÃ³s health check bem-sucedido"
        health_check_failed=1
        break
      fi
    fi
    
    sleep 1
    waited=$((waited + 1))
    PROGRESS[6]=$((50 + waited * 50 / max_wait))
    show_progress
  done
  
  # Se chegou aqui, timeout ou falha
  if [ $health_check_failed -eq 0 ]; then
    echo ""
    echo -e "${YELLOW}âš ï¸  Grafana nÃ£o respondeu apÃ³s $max_wait segundos${NC}"
    debug_log "AVISO: Timeout aguardando Grafana apÃ³s ${max_wait}s"
  fi
  
  # FALLBACK: Verificar container Docker diretamente
  if docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^myia-grafana$"; then
    echo -e "${YELLOW}ðŸ’¡ Container Grafana estÃ¡ rodando, mas health check nÃ£o respondeu${NC}"
    echo -e "${CYAN}   Grafana pode estar iniciando ainda. Verifique em: http://localhost:$GRAFANA_PORT${NC}"
    debug_log "Container encontrado mas health check falhou - marcando como running"
    PROGRESS[6]=100
    STATUS[6]="running"
    show_progress
    return 0
  fi
  
  debug_log "ERRO: Grafana nÃ£o iniciou - container nÃ£o encontrado"
  STATUS[6]="error"
  PROGRESS[6]=100
  show_progress
  show_error_logs "Grafana" "$LOG_DIR/grafana.err.log"
  echo -e "${YELLOW}ðŸ’¡ Health check falhou apÃ³s ${max_wait}s - container nÃ£o encontrado${NC}"
  echo ""
  return 1
}

start_selected_services() {
  # Validar dependÃªncias
  validate_service_dependencies
  
  # Resetar status
  for i in {1..6}; do
    if [[ "${SELECTED[$i]}" == "1" ]]; then
      STATUS[$i]="pending"
      PROGRESS[$i]=0
    fi
  done
  
  show_progress
  sleep 1
  
  # Perguntar se deve pular serviÃ§os jÃ¡ rodando
  local skip_running=0
  local any_running=0
  for i in {1..6}; do
    if [[ "${SELECTED[$i]}" == "1" ]] && [[ "${RUNNING_STATUS[$i]}" == "1" ]]; then
      any_running=1
      break
    fi
  done
  
  if [ "$any_running" -eq 1 ]; then
    echo ""
    echo -e "${YELLOW}Alguns serviÃ§os jÃ¡ estÃ£o rodando.${NC}"
    echo -ne "${CYAN}Deseja pular serviÃ§os jÃ¡ rodando? (s/N):${NC} "
    read -r response
    [[ "$response" =~ ^[Ss]$ ]] && skip_running=1
    echo ""
  fi
  
  # Iniciar serviÃ§os na ordem
  if [[ "${SELECTED[1]}" == "1" ]]; then
    if [ "$skip_running" -eq 1 ] && [[ "${RUNNING_STATUS[1]}" == "1" ]]; then
      STATUS[1]="running"
      PROGRESS[1]=100
      show_progress
    else
      start_database
    fi
    if [[ "${STATUS[1]}" == "error" ]]; then
      echo ""
      read -p "Pressione ENTER para continuar..."
    fi
  fi
  
  if [[ "${SELECTED[2]}" == "1" ]]; then
    if [ "$skip_running" -eq 1 ] && [[ "${RUNNING_STATUS[2]}" == "1" ]]; then
      STATUS[2]="running"
      PROGRESS[2]=100
      show_progress
    else
      start_backend_service
      if [[ "${STATUS[2]}" == "error" ]]; then
        echo ""
        read -p "Pressione ENTER para continuar..."
      fi
    fi
  fi
  
  if [[ "${SELECTED[3]}" == "1" ]]; then
    if [ "$skip_running" -eq 1 ] && [[ "${RUNNING_STATUS[3]}" == "1" ]]; then
      STATUS[3]="running"
      PROGRESS[3]=100
      show_progress
    else
      start_frontend_service
      if [[ "${STATUS[3]}" == "error" ]]; then
        echo ""
        read -p "Pressione ENTER para continuar..."
      fi
    fi
  fi
  
  if [[ "${SELECTED[4]}" == "1" ]]; then
    if [ "$skip_running" -eq 1 ] && [[ "${RUNNING_STATUS[4]}" == "1" ]]; then
      STATUS[4]="running"
      PROGRESS[4]=100
      show_progress
    else
      start_frontend_admin_service
      if [[ "${STATUS[4]}" == "error" ]]; then
        echo ""
        read -p "Pressione ENTER para continuar..."
      fi
    fi
  fi
  
  if [[ "${SELECTED[5]}" == "1" ]]; then
    if [ "$skip_running" -eq 1 ] && [[ "${RUNNING_STATUS[5]}" == "1" ]]; then
      STATUS[5]="running"
      PROGRESS[5]=100
      show_progress
    else
      start_worker_service
      if [[ "${STATUS[5]}" == "error" ]]; then
        echo ""
        read -p "Pressione ENTER para continuar..."
      fi
    fi
  fi
  
  if [[ "${SELECTED[6]}" == "1" ]]; then
    if [ "$skip_running" -eq 1 ] && [[ "${RUNNING_STATUS[6]}" == "1" ]]; then
      STATUS[6]="running"
      PROGRESS[6]=100
      show_progress
    else
      start_grafana_service
      if [[ "${STATUS[6]}" == "error" ]]; then
        echo ""
        read -p "Pressione ENTER para continuar..."
      fi
    fi
  fi
  
  # Mostrar resumo
  show_completion_summary
}

show_completion_summary() {
  echo ""
  echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo -e "${GREEN}âœ“ InicializaÃ§Ã£o concluÃ­da!${NC}"
  echo -e "${BLUE}â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”${NC}"
  echo ""
  echo -e "${CYAN}URLs de Acesso:${NC}"
  echo ""
  
  [[ "${SELECTED[3]}" == "1" ]] && echo -e "  ${GREEN}â€¢${NC} Frontend:       http://localhost:$FRONTEND_PORT"
  [[ "${SELECTED[4]}" == "1" ]] && echo -e "  ${GREEN}â€¢${NC} Frontend Admin: http://localhost:$FRONTEND_ADMIN_PORT"
  [[ "${SELECTED[2]}" == "1" ]] && echo -e "  ${GREEN}â€¢${NC} Backend API:    http://localhost:$BACKEND_PORT"
  [[ "${SELECTED[5]}" == "1" ]] && echo -e "  ${GREEN}â€¢${NC} Worker Health:  http://localhost:$WORKER_HEALTH_PORT"
  [[ "${SELECTED[6]}" == "1" ]] && echo -e "  ${GREEN}â€¢${NC} Grafana:        http://localhost:$GRAFANA_PORT ${YELLOW}(admin/admin)${NC}"
  
  echo ""
  echo -ne "${CYAN}Pressione ENTER para voltar ao menu...${NC}"
  read
}

# ============================================================================
# FUNÃ‡Ã•ES DE REINICIALIZAÃ‡ÃƒO
# ============================================================================

restart_service_menu() {
  clear_screen
  
  draw_box_top
  local title="              ðŸ”„ Reiniciar ServiÃ§o EspecÃ­fico              "
  echo -e "${BLUE}â•‘${WHITE}${title}${BLUE}â•‘${NC}"
  draw_box_bottom
  
  echo ""
  echo -e "${CYAN}Selecione o serviÃ§o para reiniciar:${NC}"
  echo ""
  echo -e " ${BLUE}1.${NC} Backend"
  echo -e " ${BLUE}2.${NC} Frontend"
  echo -e " ${BLUE}3.${NC} Frontend Admin"
  echo -e " ${BLUE}4.${NC} Worker"
  echo -e " ${BLUE}5.${NC} Grafana"
  echo -e " ${BLUE}0.${NC} Voltar"
  echo ""
  echo -ne "${CYAN}OpÃ§Ã£o:${NC} "
  
  read -r option
  
  case "$option" in
    1)
      restart_backend
      ;;
    2)
      restart_frontend
      ;;
    3)
      restart_frontend_admin
      ;;
    4)
      restart_worker
      ;;
    5)
      restart_grafana
      ;;
    0)
      return
      ;;
    *)
      ;;
  esac
}

restart_backend() {
  clear_screen
  echo -e "${YELLOW}ðŸ”„ Reiniciando Backend...${NC}"
  echo ""
  
  if [ -f "$PID_FILE_BACKEND" ]; then
    graceful_kill "$(cat "$PID_FILE_BACKEND")" "Backend" 10
    rm -f "$PID_FILE_BACKEND"
  fi
  
  sleep 2
  
  SELECTED[2]=1
  STATUS[2]="pending"
  PROGRESS[2]=0
  start_backend_service
  
  echo ""
  read -p "Pressione ENTER para continuar..."
}

restart_frontend() {
  clear_screen
  echo -e "${YELLOW}ðŸ”„ Reiniciando Frontend...${NC}"
  echo ""
  
  if [ -f "$PID_FILE_FRONTEND" ]; then
    graceful_kill "$(cat "$PID_FILE_FRONTEND")" "Frontend" 10
    rm -f "$PID_FILE_FRONTEND"
  fi
  
  sleep 2
  
  SELECTED[3]=1
  STATUS[3]="pending"
  PROGRESS[3]=0
  start_frontend_service
  
  echo ""
  read -p "Pressione ENTER para continuar..."
}

restart_frontend_admin() {
  clear_screen
  echo -e "${YELLOW}ðŸ”„ Reiniciando Frontend Admin...${NC}"
  echo ""
  
  if [ -f "$PID_FILE_FRONTEND_ADMIN" ]; then
    graceful_kill "$(cat "$PID_FILE_FRONTEND_ADMIN")" "Frontend Admin" 10
    rm -f "$PID_FILE_FRONTEND_ADMIN"
  fi
  
  sleep 2
  
  SELECTED[4]=1
  STATUS[4]="pending"
  PROGRESS[4]=0
  start_frontend_admin_service
  
  echo ""
  read -p "Pressione ENTER para continuar..."
}

restart_worker() {
  clear_screen
  echo -e "${YELLOW}ðŸ”„ Reiniciando Worker...${NC}"
  echo ""
  
  if [ -f "$PID_FILE_WORKER" ]; then
    graceful_kill "$(cat "$PID_FILE_WORKER")" "Worker" 10
    rm -f "$PID_FILE_WORKER"
  fi
  
  sleep 2
  
  SELECTED[5]=1
  STATUS[5]="pending"
  PROGRESS[5]=0
  start_worker_service
  
  echo ""
  read -p "Pressione ENTER para continuar..."
}

restart_grafana() {
  clear_screen
  echo -e "${YELLOW}ðŸ”„ Reiniciando Grafana...${NC}"
  echo ""
  
  # Parar Grafana
  if [ -f "$OBSERVABILITY_DIR/stop.sh" ]; then
    echo -e "${BLUE}Parando Grafana...${NC}"
    (cd "$OBSERVABILITY_DIR" && ./stop.sh >/dev/null 2>&1) || true
  fi
  
  sleep 2
  
  SELECTED[6]=1
  STATUS[6]="pending"
  PROGRESS[6]=0
  start_grafana_service
  
  echo ""
  read -p "Pressione ENTER para continuar..."
}

# ============================================================================
# FUNÃ‡Ã•ES DE VISUALIZAÃ‡ÃƒO DE LOGS
# ============================================================================

view_logs_menu() {
  clear_screen
  
  draw_box_top
  local title="              ðŸ“‹ Ver Logs em Tempo Real                    "
  echo -e "${BLUE}â•‘${WHITE}${title}${BLUE}â•‘${NC}"
  draw_box_bottom
  
  echo ""
  echo -e "${CYAN}Selecione o log para visualizar:${NC}"
  echo ""
  echo -e " ${BLUE}1.${NC} Backend (stdout)"
  echo -e " ${BLUE}2.${NC} Backend (stderr)"
  echo -e " ${BLUE}3.${NC} Frontend (stdout)"
  echo -e " ${BLUE}4.${NC} Frontend (stderr)"
  echo -e " ${BLUE}5.${NC} Worker (stdout)"
  echo -e " ${BLUE}6.${NC} Worker (stderr)"
  echo -e " ${BLUE}7.${NC} Frontend Admin (stdout)"
  echo -e " ${BLUE}8.${NC} Frontend Admin (stderr)"
  echo -e " ${BLUE}0.${NC} Voltar"
  echo ""
  echo -e "${YELLOW}ðŸ’¡ Pressione Ctrl+C para sair da visualizaÃ§Ã£o${NC}"
  echo ""
  echo -ne "${CYAN}OpÃ§Ã£o:${NC} "
  
  read -r option
  
  local log_file=""
  
  case "$option" in
    1)
      log_file="$LOG_DIR/backend.out.log"
      ;;
    2)
      log_file="$LOG_DIR/backend.err.log"
      ;;
    3)
      log_file="$LOG_DIR/frontend.out.log"
      ;;
    4)
      log_file="$LOG_DIR/frontend.err.log"
      ;;
    5)
      log_file="$OUT_LOG_WORKER"
      ;;
    6)
      log_file="$ERR_LOG_WORKER"
      ;;
    7)
      log_file="$OUT_LOG_FRONTEND_ADMIN"
      ;;
    8)
      log_file="$ERR_LOG_FRONTEND_ADMIN"
      ;;
    0)
      return
      ;;
    *)
      return
      ;;
  esac
  
  if [ -n "$log_file" ]; then
    clear_screen
    echo -e "${CYAN}Visualizando: $log_file${NC}"
    echo -e "${YELLOW}Pressione Ctrl+C para voltar ao menu${NC}"
    echo ""
    
    # Criar arquivo se nÃ£o existir
    touch "$log_file"
    
    # Usar tail -f com trap para capturar Ctrl+C
    (
      trap 'exit 0' INT
      tail -f "$log_file"
    )
    
    # ApÃ³s sair do tail, aguardar ENTER
    echo ""
    read -p "Pressione ENTER para continuar..."
  fi
}

# ============================================================================
# FUNÃ‡Ã•ES DE LIMPEZA DE LOGS
# ============================================================================

clean_old_logs() {
  clear_screen
  echo -e "${YELLOW}ðŸ—‘ï¸  Limpar Logs Antigos${NC}"
  echo ""
  
  local total_size=$(du -sh "$LOG_DIR" 2>/dev/null | cut -f1)
  echo -e "${CYAN}Tamanho total dos logs: ${WHITE}$total_size${NC}"
  echo ""
  
  # Listar arquivos de log
  echo -e "${CYAN}Arquivos de log encontrados:${NC}"
  local log_count=0
  for log_file in "$LOG_DIR"/*.log "$LOG_DIR"/*.log.*; do
    if [ -f "$log_file" ]; then
      local size=$(du -h "$log_file" 2>/dev/null | cut -f1)
      echo -e "  ${GRAY}â€¢ $(basename "$log_file") (${size})${NC}"
      log_count=$((log_count + 1))
    fi
  done
  
  if [ "$log_count" -eq 0 ]; then
    echo -e "${GRAY}  Nenhum arquivo de log encontrado${NC}"
    echo ""
    read -p "Pressione ENTER para continuar..."
    return
  fi
  
  echo ""
  read -p "Deseja deletar todos os logs? (s/N): " -n 1 -r
  echo ""
  
  if [[ $REPLY =~ ^[Ss]$ ]]; then
    debug_log "Deletando todos os logs do diretÃ³rio $LOG_DIR"
    rm -f "$LOG_DIR"/*.log "$LOG_DIR"/*.log.* 2>/dev/null
    echo -e "${GREEN}âœ“ Logs deletados com sucesso${NC}"
    debug_log "Logs deletados: $log_count arquivos"
  else
    echo -e "${GRAY}OperaÃ§Ã£o cancelada${NC}"
    debug_log "Limpeza de logs cancelada pelo usuÃ¡rio"
  fi
  
  echo ""
  read -p "Pressione ENTER para continuar..."
}

# ============================================================================
# FUNÃ‡Ã•ES DE PERFIS
# ============================================================================

save_profile() {
  clear_screen
  
  draw_box_top
  local title="              ðŸ’¾ Salvar Perfil de InicializaÃ§Ã£o             "
  echo -e "${BLUE}â•‘${WHITE}${title}${BLUE}â•‘${NC}"
  draw_box_bottom
  
  echo ""
  echo -e "${CYAN}Digite o nome do perfil:${NC}"
  echo -ne "${CYAN}Nome:${NC} "
  
  read -r profile_name
  
  # Validar nome
  if [ -z "$profile_name" ]; then
    echo ""
    echo -e "${RED}âŒ Nome invÃ¡lido${NC}"
    echo ""
    read -p "Pressione ENTER para continuar..."
    return
  fi
  
  # Criar diretÃ³rio de perfis se nÃ£o existir
  local profiles_dir="$ROOT_DIR/.profiles"
  mkdir -p "$profiles_dir"
  
  # Salvar perfil
  local profile_file="$profiles_dir/${profile_name}.profile"
  
  echo "# MyIA Service Profile: $profile_name" > "$profile_file"
  echo "# Created: $(date)" >> "$profile_file"
  
  for i in {1..6}; do
    echo "$i=${SELECTED[$i]}" >> "$profile_file"
  done
  
  echo ""
  echo -e "${GREEN}âœ“ Perfil '$profile_name' salvo com sucesso!${NC}"
  echo -e "${GRAY}LocalizaÃ§Ã£o: $profile_file${NC}"
  echo ""
  read -p "Pressione ENTER para continuar..."
}

load_profile() {
  clear_screen
  
  draw_box_top
  local title="              ðŸ“‚ Carregar Perfil de InicializaÃ§Ã£o           "
  echo -e "${BLUE}â•‘${WHITE}${title}${BLUE}â•‘${NC}"
  draw_box_bottom
  
  echo ""
  
  local profiles_dir="$ROOT_DIR/.profiles"
  
  # Verificar se diretÃ³rio existe
  if [ ! -d "$profiles_dir" ]; then
    echo -e "${YELLOW}âš ï¸  Nenhum perfil encontrado${NC}"
    echo ""
    read -p "Pressione ENTER para continuar..."
    return
  fi
  
  # Listar perfis disponÃ­veis
  local profiles=($(ls "$profiles_dir"/*.profile 2>/dev/null | xargs -n 1 basename | sed 's/.profile$//'))
  
  if [ ${#profiles[@]} -eq 0 ]; then
    echo -e "${YELLOW}âš ï¸  Nenhum perfil encontrado${NC}"
    echo ""
    read -p "Pressione ENTER para continuar..."
    return
  fi
  
  echo -e "${CYAN}Perfis disponÃ­veis:${NC}"
  echo ""
  
  local idx=1
  for profile in "${profiles[@]}"; do
    echo -e " ${BLUE}$idx.${NC} $profile"
    idx=$((idx + 1))
  done
  
  echo -e " ${BLUE}0.${NC} Voltar"
  echo ""
  echo -ne "${CYAN}OpÃ§Ã£o:${NC} "
  
  read -r option
  
  # Validar opÃ§Ã£o
  if [ "$option" -eq 0 ] 2>/dev/null; then
    return
  fi
  
  if [ "$option" -ge 1 ] 2>/dev/null && [ "$option" -le ${#profiles[@]} ]; then
    local selected_profile="${profiles[$((option - 1))]}"
    local profile_file="$profiles_dir/${selected_profile}.profile"
    
    # Carregar perfil
    if [ -f "$profile_file" ]; then
      # Resetar seleÃ§Ãµes
      deselect_all
      
      # Carregar do arquivo
      while IFS='=' read -r key value; do
        # Ignorar comentÃ¡rios e linhas vazias
        [[ "$key" =~ ^#.*$ ]] && continue
        [[ -z "$key" ]] && continue
        
        if [[ "$key" =~ ^[1-6]$ ]]; then
          SELECTED[$key]=$value
        fi
      done < "$profile_file"
      
      echo ""
      echo -e "${GREEN}âœ“ Perfil '$selected_profile' carregado com sucesso!${NC}"
      echo ""
      read -p "Pressione ENTER para continuar..."
    else
      echo ""
      echo -e "${RED}âŒ Erro ao carregar perfil${NC}"
      echo ""
      read -p "Pressione ENTER para continuar..."
    fi
  fi
}

# ============================================================================
# FUNÃ‡Ã•ES DE STATUS MELHORADO
# ============================================================================

get_uptime() {
  local pid=$1
  
  if [ -z "$pid" ] || ! kill -0 "$pid" >/dev/null 2>&1; then
    echo ""
    return
  fi
  
  # Obter tempo de inÃ­cio do processo (em segundos desde epoch)
  local start_time=$(ps -o lstart= -p "$pid" 2>/dev/null)
  
  if [ -z "$start_time" ]; then
    echo ""
    return
  fi
  
  # Converter para timestamp
  local start_epoch=$(date -d "$start_time" +%s 2>/dev/null)
  local current_epoch=$(date +%s)
  
  if [ -z "$start_epoch" ]; then
    echo ""
    return
  fi
  
  local uptime_seconds=$((current_epoch - start_epoch))
  
  # Formatar uptime
  local hours=$((uptime_seconds / 3600))
  local minutes=$(((uptime_seconds % 3600) / 60))
  local seconds=$((uptime_seconds % 60))
  
  if [ $hours -gt 0 ]; then
    echo ", uptime: ${hours}h ${minutes}m"
  elif [ $minutes -gt 0 ]; then
    echo ", uptime: ${minutes}m ${seconds}s"
  else
    echo ", uptime: ${seconds}s"
  fi
}

# ============================================================================
# STATUS E CONTROLE
# ============================================================================

show_status() {
  clear_screen
  
  draw_box_top
  local title="              ðŸ“Š Status dos ServiÃ§os MyIA                "
  echo -e "${BLUE}â•‘${WHITE}${title}${BLUE}â•‘${NC}"
  draw_box_bottom
  
  echo ""
  
  # Redis
  echo -ne "${BLUE}Redis (porta $REDIS_PORT):${NC} "
  if docker ps --format '{{.Names}}' | grep -q "^myia-redis$"; then
    echo -e "${GREEN}âœ“ Rodando${NC}"
  else
    echo -e "${GRAY}â—‹ Parado${NC}"
  fi
  
  # PostgreSQL
  echo -ne "${BLUE}PostgreSQL (porta $POSTGRES_PORT):${NC} "
  if lsof -ti:$POSTGRES_PORT >/dev/null 2>&1; then
    echo -e "${GREEN}âœ“ Rodando${NC}"
  else
    echo -e "${GRAY}â—‹ Parado${NC}"
  fi
  
  # Backend
  echo -ne "${BLUE}Backend (porta $BACKEND_PORT):${NC} "
  if [ -f "$PID_FILE_BACKEND" ] && kill -0 "$(cat "$PID_FILE_BACKEND")" >/dev/null 2>&1; then
    local pid=$(cat "$PID_FILE_BACKEND")
    local uptime=$(get_uptime "$pid")
    echo -e "${GREEN}âœ“ Rodando${NC} (PID $pid$uptime)"
    echo -e "   ${CYAN}â†’ http://localhost:$BACKEND_PORT${NC}"
  else
    echo -e "${GRAY}â—‹ Parado${NC}"
  fi
  
  # Frontend
  echo -ne "${BLUE}Frontend (porta $FRONTEND_PORT):${NC} "
  if [ -f "$PID_FILE_FRONTEND" ] && kill -0 "$(cat "$PID_FILE_FRONTEND")" >/dev/null 2>&1; then
    local pid=$(cat "$PID_FILE_FRONTEND")
    local uptime=$(get_uptime "$pid")
    echo -e "${GREEN}âœ“ Rodando${NC} (PID $pid$uptime)"
    echo -e "   ${CYAN}â†’ http://localhost:$FRONTEND_PORT${NC}"
  else
    echo -e "${GRAY}â—‹ Parado${NC}"
  fi
  
  # Frontend Admin
  echo -ne "${BLUE}Frontend Admin (porta $FRONTEND_ADMIN_PORT):${NC} "
  if [ -f "$PID_FILE_FRONTEND_ADMIN" ] && kill -0 "$(cat "$PID_FILE_FRONTEND_ADMIN")" >/dev/null 2>&1; then
    local pid=$(cat "$PID_FILE_FRONTEND_ADMIN")
    local uptime=$(get_uptime "$pid")
    echo -e "${GREEN}âœ“ Rodando${NC} (PID $pid$uptime)"
    echo -e "   ${CYAN}â†’ http://localhost:$FRONTEND_ADMIN_PORT${NC}"
  else
    echo -e "${GRAY}â—‹ Parado${NC}"
  fi
  
  # Worker
  echo -ne "${BLUE}Worker:${NC} "
  if [ -f "$PID_FILE_WORKER" ] && kill -0 "$(cat "$PID_FILE_WORKER")" >/dev/null 2>&1; then
    local pid=$(cat "$PID_FILE_WORKER")
    local uptime=$(get_uptime "$pid")
    echo -e "${GREEN}âœ“ Rodando${NC} (PID $pid$uptime)"
  else
    echo -e "${GRAY}â—‹ Parado${NC}"
  fi
  
  # Grafana
  echo -ne "${BLUE}Grafana (porta $GRAFANA_PORT):${NC} "
  if lsof -ti:$GRAFANA_PORT >/dev/null 2>&1; then
    # Verificar se health check responde
    if curl -s http://localhost:$GRAFANA_PORT/api/health >/dev/null 2>&1; then
      echo -e "${GREEN}âœ“ Rodando${NC} (health check OK)"
      echo -e "   ${CYAN}â†’ http://localhost:$GRAFANA_PORT ${YELLOW}(admin/admin)${NC}"
    else
      echo -e "${YELLOW}âš ï¸  Porta aberta mas nÃ£o responde${NC}"
      echo -e "   ${CYAN}â†’ http://localhost:$GRAFANA_PORT ${GRAY}(pode estar iniciando)${NC}"
    fi
  else
    # Verificar se container Docker estÃ¡ rodando
    if docker ps --format '{{.Names}}' | grep -q "grafana"; then
      echo -e "${YELLOW}âš ï¸  Container rodando mas porta nÃ£o aberta${NC}"
      echo -e "   ${GRAY}(verifique mapeamento de portas)${NC}"
    else
      echo -e "${GRAY}â—‹ Parado${NC}"
    fi
  fi
  
  echo ""
  echo -ne "${CYAN}Pressione ENTER para voltar ao menu...${NC}"
  read
}

stop_all_services() {
  clear_screen
  
  echo ""
  echo -e "${YELLOW}ðŸ›‘ Parando serviÃ§os...${NC}"
  echo ""
  
  # Parar Backend
  if [ -f "$PID_FILE_BACKEND" ] && kill -0 "$(cat "$PID_FILE_BACKEND")" >/dev/null 2>&1; then
    if graceful_kill "$(cat "$PID_FILE_BACKEND")" "Backend" 10; then
      rm -f "$PID_FILE_BACKEND"
      echo -e "${GREEN}âœ“ Backend parado com sucesso${NC}"
    fi
  else
    echo -e "${YELLOW}âš ï¸  Backend jÃ¡ estava parado${NC}"
  fi
  
  # Parar Frontend
  if [ -f "$PID_FILE_FRONTEND" ] && kill -0 "$(cat "$PID_FILE_FRONTEND")" >/dev/null 2>&1; then
    if graceful_kill "$(cat "$PID_FILE_FRONTEND")" "Frontend" 10; then
      rm -f "$PID_FILE_FRONTEND"
      echo -e "${GREEN}âœ“ Frontend parado com sucesso${NC}"
    fi
  else
    echo -e "${YELLOW}âš ï¸  Frontend jÃ¡ estava parado${NC}"
  fi
  
  # Parar Frontend Admin
  if [ -f "$PID_FILE_FRONTEND_ADMIN" ] && kill -0 "$(cat "$PID_FILE_FRONTEND_ADMIN")" >/dev/null 2>&1; then
    if graceful_kill "$(cat "$PID_FILE_FRONTEND_ADMIN")" "Frontend Admin" 10; then
      rm -f "$PID_FILE_FRONTEND_ADMIN"
      echo -e "${GREEN}âœ“ Frontend Admin parado com sucesso${NC}"
    fi
  else
    echo -e "${YELLOW}âš ï¸  Frontend Admin jÃ¡ estava parado${NC}"
  fi
  
  # Worker (verificar se estava rodando junto com backend)
  if [ -f "$PID_FILE_WORKER" ] && kill -0 "$(cat "$PID_FILE_WORKER")" >/dev/null 2>&1; then
    if graceful_kill "$(cat "$PID_FILE_WORKER")" "Worker" 10; then
      rm -f "$PID_FILE_WORKER"
      echo -e "${GREEN}âœ“ Worker parado com sucesso${NC}"
    fi
  else
    echo -e "${YELLOW}âš ï¸  Worker jÃ¡ estava parado${NC}"
  fi
  
  # Parar Redis
  if docker ps --format '{{.Names}}' | grep -q "^myia-redis$"; then
    echo -e "${BLUE}Parando Redis...${NC}"
    docker stop myia-redis >/dev/null 2>&1 || true
    docker rm myia-redis >/dev/null 2>&1 || true
    echo -e "${GREEN}âœ“ Redis parado com sucesso${NC}"
  else
    echo -e "${YELLOW}âš ï¸  Redis jÃ¡ estava parado${NC}"
  fi
  
  # Parar Grafana
  if lsof -ti:$GRAFANA_PORT >/dev/null 2>&1; then
    echo -e "${BLUE}Parando Grafana...${NC}"
    if [ -f "$OBSERVABILITY_DIR/stop.sh" ]; then
      (cd "$OBSERVABILITY_DIR" && ./stop.sh >/dev/null 2>&1) || true
    fi
    echo -e "${GREEN}âœ“ Grafana parado com sucesso${NC}"
  else
    echo -e "${YELLOW}âš ï¸  Grafana jÃ¡ estava parado${NC}"
  fi
  
  echo ""
  echo -e "${GREEN}âœ“ OperaÃ§Ã£o de parada concluÃ­da.${NC}"
  echo ""
  read -p "Pressione ENTER para voltar ao menu..."
}

# ============================================================================
# MAIN LOOP
# ============================================================================

main() {
  # Verificar modo debug
  if [[ "${1:-}" == "--debug" ]] || [[ "${1:-}" == "-d" ]]; then
    DEBUG_MODE=1
    echo -e "${CYAN}ðŸ› Modo Debug ativado${NC}"
    echo ""
  fi
  
  # Trap para restaurar cursor ao sair
  trap show_cursor EXIT
  
  # ValidaÃ§Ãµes iniciais
  check_prerequisites
  validate_directories
  validate_env_files
  cleanup_orphan_pids
  
  # Rotacionar logs se necessÃ¡rio
  rotate_logs
  
  while true; do
    show_menu
    read -r option
    
    case "$option" in
      1|2|3|4|5|6)
        toggle_service "$option"
        ;;
      7)
        select_all
        hide_cursor
        start_selected_services
        show_cursor
        deselect_all
        ;;
      8)
        show_status
        ;;
      9)
        stop_all_services
        ;;
      r|R)
        restart_service_menu
        ;;
      l|L)
        view_logs_menu
        ;;
      c|C)
        clean_old_logs
        ;;
      s|S)
        save_profile
        ;;
      p|P)
        load_profile
        ;;
      0)
        show_cursor
        echo ""
        echo -e "${GREEN}AtÃ© logo!${NC}"
        echo ""
        exit 0
        ;;
      "")
        # Enter sem opÃ§Ã£o - iniciar serviÃ§os selecionados
        local any_selected=0
        for i in {1..6}; do
          [[ "${SELECTED[$i]}" == "1" ]] && any_selected=1
        done
        
        if [ "$any_selected" -eq 1 ]; then
          hide_cursor
          start_selected_services
          show_cursor
          deselect_all
        fi
        ;;
      *)
        ;;
    esac
  done
}

# Executar
main
